%&tex
% !TEX program = xelatex
% !TeX TS-program = xelatex
% !BIB TS-program = biber
% !TeX encoding = UTF-8
% !TeX spellcheck = en_US
% !TeX root = ../thesis.tex

%% ==============================
\section{Introduction}
\label{sec:Introduction}
%% ==============================

\glspl{acn:plc} are a staple of industrial automation since the early 1970's.
They are used to automate and control all kinds of industrial tasks, from manufacturing equipment to fluid control systems~\cite{Erickson:1996aa}.
They can easily be maintained and extended due to their simplicity and modularity.
This allows for long runtime while being flexible enough to adapt to changes in the manufacturing process.

In contrast to the modularity in hardware, the software running on a~\gls{acn:plc} is more static.
The common way of programming a PLC is with one of the five languages defined in the \textit{IEC 61131-3} standard~\cite{Plcopen:61131-3}.
This standard defines two textual languages (\gls{acn:IL} and~\gls{acn:ST}), two graphical languages (\gls{acn:LD} and~\gls{acn:FBD}) and one hybrid language (\gls{acn:SFC}).
The focus of the standard languages is, to allow electrical and automation engineers to program the~\gls{acn:plc} in a way that is close to common electrical relays.
Reasoning behind this is to keep the~\gls{acn:plc} as close to the previously used nonprogrammable relays as possible.
Therefore, the graphical languages are composing low level logical operations to generate outputs.
The textual languages allow for a more high-level view on the operations, while still operating close to the basic logical operations.

This makes building more complex applications on a~\gls{acn:plc} harder and reduces the flexibility of the systems to adapt from a software side.
When~\glspl{acn:plc} and the corresponding languages were designed this level of flexibility was enough, but with the rise of Industry 4.0, more flexible and integrated automation solutions are more important than ever.
An example would be the current development in~\gls{acn:ml} for industrial applications.
It makes adapting automation systems to quickly react to sensor data processed by a~\gls{acn:ml} system a requirement.
This makes faster development without the expense of formal correctness a high priority for automation solutions.
The developers of these automation solutions need to adapt to changes quicker and more often, with the changes requiring larger, more complex solutions.
In common high-level languages, like C/C++ or Python, extensive libraries and high-level abstractions can reduce the time it takes to create such a piece of software, whereas with the common~\gls{acn:plc} languages this isn't the case.
Due to the static and low-level approach to~\gls{acn:plc} programming other ways must be found to allow for quicker and more integrated development of solutions.

\paragraph{Objective}
Therefore this seminar work investigates different approaches to automated~\gls{acn:plc} programming from high level abstractions.
I investigate the state-of-the-art on different approaches to automated~\gls{acn:plc} programming.
For this I look at different transformations and the related risks for usage in real world scenarios.

\paragraph{Method}
There are several different approaches from the past decades to this question.
One feasible way of reducing programming time, is to allow C or C++ code to run on the~\gls{acn:plc}, allowing to make use of its high-level abstractions.
Another possibility is to use a model or a formal description of the systems behavior to generate a program realizing this on a~\gls{acn:plc}.
Both approaches have found usage in recent years, as they have inherent strengths and weaknesses in the context of automation.
For this reason, I investigate both approaches to this problem.
This allows me to give a broad overview of the current state-of-the-art for modern~\gls{acn:plc} program development.

\paragraph{Outline}
The following work will be structured as follows: 
Section~\ref{sec:plc} outlines the basics of~\glspl{acn:plc} and the IEC 61131-3 languages. 
Section~\ref{sec:c_methods} discusses methods to program a~\gls{acn:plc} with the high-level languages C and C++.
Section~\ref{sec:formal_methods} investigates the state-of-the art of formal model-based program generation and compares the different approaches.
Automated program generation in safety critical environments is a considerable risk, therefore section~\ref{sec:risks} analyzes the risks of the presented approaches.
Finally, section~\ref{sec:conclusion} gives an overview of the found approaches and risks and summarizes the findings.